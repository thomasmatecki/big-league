/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @interface ILeague
 */
export interface ILeague {
    /**
     * 
     * @type {number}
     * @memberof League
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    name: string;
}

/**
 * 
 * @class League
 */
export class League implements ILeague{
        /**
         * @type {number}
         * @memberof League
         */
        id: number;
        /**
         * @type {string}
         * @memberof League
         */
        url: string;
        /**
         * @type {string}
         * @memberof League
         */
        name: string;
}


/**
 * 
 * @interface ILeagueError
 */
export interface ILeagueError {
    /**
     * 
     * @type {Array<string>}
     * @memberof LeagueError
     */
    name?: Array<string>;
}

/**
 * 
 * @class LeagueError
 */
export class LeagueError implements ILeagueError{
        /**
         * @type {Array<string>}
         * @memberof LeagueError
         */
        name: Array<string>;
}


/**
 * 
 * @interface ILeagueList
 */
export interface ILeagueList {
    /**
     * 
     * @type {number}
     * @memberof LeagueList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof LeagueList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeagueList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<League>}
     * @memberof LeagueList
     */
    results?: Array<League>;
}

/**
 * 
 * @class LeagueList
 */
export class LeagueList implements ILeagueList{
        /**
         * @type {number}
         * @memberof LeagueList
         */
        count: number;
        /**
         * @type {string}
         * @memberof LeagueList
         */
        next: string | null;
        /**
         * @type {string}
         * @memberof LeagueList
         */
        previous: string | null;
        /**
         * @type {Array<League>}
         * @memberof LeagueList
         */
        results: Array<League>;
}


/**
 * 
 * @interface IMatch
 */
export interface IMatch {
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    id?: number;
    /**
     * 
     * @type {Array<MatchTeams>}
     * @memberof Match
     */
    teams: Array<MatchTeams>;
    /**
     * 
     * @type {MatchTeams}
     * @memberof Match
     */
    season: MatchTeams;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    datetime: string;
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    location: number;
}

/**
 * 
 * @class Match
 */
export class Match implements IMatch{
        /**
         * @type {number}
         * @memberof Match
         */
        id: number;
        /**
         * @type {Array<MatchTeams>}
         * @memberof Match
         */
        teams: Array<MatchTeams>;
        /**
         * @type {MatchTeams}
         * @memberof Match
         */
        season: MatchTeams;
        /**
         * @type {string}
         * @memberof Match
         */
        datetime: string;
        /**
         * @type {number}
         * @memberof Match
         */
        location: number;
}


/**
 * 
 * @interface IMatchError
 */
export interface IMatchError {
    /**
     * 
     * @type {Array<string>}
     * @memberof MatchError
     */
    teams?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MatchError
     */
    season?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MatchError
     */
    datetime?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MatchError
     */
    location?: Array<string>;
}

/**
 * 
 * @class MatchError
 */
export class MatchError implements IMatchError{
        /**
         * @type {Array<string>}
         * @memberof MatchError
         */
        teams: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof MatchError
         */
        season: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof MatchError
         */
        datetime: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof MatchError
         */
        location: Array<string>;
}


/**
 * 
 * @interface IMatchList
 */
export interface IMatchList {
    /**
     * 
     * @type {number}
     * @memberof MatchList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Match>}
     * @memberof MatchList
     */
    results?: Array<Match>;
}

/**
 * 
 * @class MatchList
 */
export class MatchList implements IMatchList{
        /**
         * @type {number}
         * @memberof MatchList
         */
        count: number;
        /**
         * @type {string}
         * @memberof MatchList
         */
        next: string | null;
        /**
         * @type {string}
         * @memberof MatchList
         */
        previous: string | null;
        /**
         * @type {Array<Match>}
         * @memberof MatchList
         */
        results: Array<Match>;
}


/**
 * 
 * @interface IMatchTeams
 */
export interface IMatchTeams {
    /**
     * 
     * @type {number}
     * @memberof MatchTeams
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchTeams
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchTeams
     */
    name: string;
}

/**
 * 
 * @class MatchTeams
 */
export class MatchTeams implements IMatchTeams{
        /**
         * @type {number}
         * @memberof MatchTeams
         */
        id: number;
        /**
         * @type {string}
         * @memberof MatchTeams
         */
        url: string;
        /**
         * @type {string}
         * @memberof MatchTeams
         */
        name: string;
}


/**
 * 
 * @interface IPlayer
 */
export interface IPlayer {
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    last_name: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    first_name: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    display_name: string;
    /**
     * 
     * @type {Array<MatchTeams>}
     * @memberof Player
     */
    teams?: Array<MatchTeams>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Player
     */
    team_ids?: Array<number>;
}

/**
 * 
 * @class Player
 */
export class Player implements IPlayer{
        /**
         * @type {number}
         * @memberof Player
         */
        id: number;
        /**
         * @type {string}
         * @memberof Player
         */
        url: string;
        /**
         * @type {string}
         * @memberof Player
         */
        email: string;
        /**
         * @type {string}
         * @memberof Player
         */
        last_name: string;
        /**
         * @type {string}
         * @memberof Player
         */
        first_name: string;
        /**
         * @type {string}
         * @memberof Player
         */
        display_name: string;
        /**
         * @type {Array<MatchTeams>}
         * @memberof Player
         */
        teams: Array<MatchTeams>;
        /**
         * @type {Array<number>}
         * @memberof Player
         */
        team_ids: Array<number>;
}


/**
 * 
 * @interface IPlayerError
 */
export interface IPlayerError {
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    email?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    last_name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    first_name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    display_name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    team_ids?: Array<string>;
}

/**
 * 
 * @class PlayerError
 */
export class PlayerError implements IPlayerError{
        /**
         * @type {Array<string>}
         * @memberof PlayerError
         */
        email: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof PlayerError
         */
        last_name: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof PlayerError
         */
        first_name: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof PlayerError
         */
        display_name: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof PlayerError
         */
        team_ids: Array<string>;
}


/**
 * 
 * @interface IPlayerList
 */
export interface IPlayerList {
    /**
     * 
     * @type {number}
     * @memberof PlayerList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlayerList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Player>}
     * @memberof PlayerList
     */
    results?: Array<Player>;
}

/**
 * 
 * @class PlayerList
 */
export class PlayerList implements IPlayerList{
        /**
         * @type {number}
         * @memberof PlayerList
         */
        count: number;
        /**
         * @type {string}
         * @memberof PlayerList
         */
        next: string | null;
        /**
         * @type {string}
         * @memberof PlayerList
         */
        previous: string | null;
        /**
         * @type {Array<Player>}
         * @memberof PlayerList
         */
        results: Array<Player>;
}


/**
 * 
 * @interface IProfile
 */
export interface IProfile {
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    first_name: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    last_name: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    display_name?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    biography?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    date_joined?: string;
    /**
     * 
     * @type {any}
     * @memberof Profile
     */
    image?: any | null;
}

/**
 * 
 * @class Profile
 */
export class Profile implements IProfile{
        /**
         * @type {string}
         * @memberof Profile
         */
        first_name: string;
        /**
         * @type {string}
         * @memberof Profile
         */
        last_name: string;
        /**
         * @type {string}
         * @memberof Profile
         */
        email: string;
        /**
         * @type {string}
         * @memberof Profile
         */
        password: string;
        /**
         * @type {string}
         * @memberof Profile
         */
        display_name: string;
        /**
         * @type {string}
         * @memberof Profile
         */
        biography: string;
        /**
         * @type {string}
         * @memberof Profile
         */
        date_joined: string;
        /**
         * @type {any}
         * @memberof Profile
         */
        image: any | null;
}


/**
 * 
 * @interface IProfileError
 */
export interface IProfileError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileError
     */
    first_name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileError
     */
    last_name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileError
     */
    email?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileError
     */
    password?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileError
     */
    display_name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileError
     */
    biography?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileError
     */
    image?: Array<string>;
}

/**
 * 
 * @class ProfileError
 */
export class ProfileError implements IProfileError{
        /**
         * @type {Array<string>}
         * @memberof ProfileError
         */
        first_name: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof ProfileError
         */
        last_name: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof ProfileError
         */
        email: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof ProfileError
         */
        password: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof ProfileError
         */
        display_name: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof ProfileError
         */
        biography: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof ProfileError
         */
        image: Array<string>;
}


/**
 * 
 * @interface ISchedule
 */
export interface ISchedule {
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    id?: number;
    /**
     * 
     * @type {MatchTeams}
     * @memberof Schedule
     */
    team: MatchTeams;
    /**
     * 
     * @type {MatchTeams}
     * @memberof Schedule
     */
    opponent: MatchTeams;
    /**
     * 
     * @type {ScheduleMatch}
     * @memberof Schedule
     */
    match: ScheduleMatch;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    datetime: string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    location: string;
    /**
     * 
     * @type {boolean}
     * @memberof Schedule
     */
    away: boolean;
}

/**
 * 
 * @class Schedule
 */
export class Schedule implements ISchedule{
        /**
         * @type {number}
         * @memberof Schedule
         */
        id: number;
        /**
         * @type {MatchTeams}
         * @memberof Schedule
         */
        team: MatchTeams;
        /**
         * @type {MatchTeams}
         * @memberof Schedule
         */
        opponent: MatchTeams;
        /**
         * @type {ScheduleMatch}
         * @memberof Schedule
         */
        match: ScheduleMatch;
        /**
         * @type {string}
         * @memberof Schedule
         */
        datetime: string;
        /**
         * @type {string}
         * @memberof Schedule
         */
        location: string;
        /**
         * @type {boolean}
         * @memberof Schedule
         */
        away: boolean;
}


/**
 * 
 * @interface IScheduleList
 */
export interface IScheduleList {
    /**
     * 
     * @type {number}
     * @memberof ScheduleList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduleList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Schedule>}
     * @memberof ScheduleList
     */
    results?: Array<Schedule>;
}

/**
 * 
 * @class ScheduleList
 */
export class ScheduleList implements IScheduleList{
        /**
         * @type {number}
         * @memberof ScheduleList
         */
        count: number;
        /**
         * @type {string}
         * @memberof ScheduleList
         */
        next: string | null;
        /**
         * @type {string}
         * @memberof ScheduleList
         */
        previous: string | null;
        /**
         * @type {Array<Schedule>}
         * @memberof ScheduleList
         */
        results: Array<Schedule>;
}


/**
 * 
 * @interface IScheduleMatch
 */
export interface IScheduleMatch {
    /**
     * 
     * @type {number}
     * @memberof ScheduleMatch
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduleMatch
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleMatch
     */
    name?: string;
}

/**
 * 
 * @class ScheduleMatch
 */
export class ScheduleMatch implements IScheduleMatch{
        /**
         * @type {number}
         * @memberof ScheduleMatch
         */
        id: number;
        /**
         * @type {string}
         * @memberof ScheduleMatch
         */
        url: string;
        /**
         * @type {string}
         * @memberof ScheduleMatch
         */
        name: string;
}


/**
 * 
 * @interface ISeason
 */
export interface ISeason {
    /**
     * 
     * @type {number}
     * @memberof Season
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    name: string;
    /**
     * 
     * @type {MatchTeams}
     * @memberof Season
     */
    league: MatchTeams;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    start_date: string;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    end_date: string;
    /**
     * 
     * @type {Array<MatchTeams>}
     * @memberof Season
     */
    teams: Array<MatchTeams>;
}

/**
 * 
 * @class Season
 */
export class Season implements ISeason{
        /**
         * @type {number}
         * @memberof Season
         */
        id: number;
        /**
         * @type {string}
         * @memberof Season
         */
        url: string;
        /**
         * @type {string}
         * @memberof Season
         */
        name: string;
        /**
         * @type {MatchTeams}
         * @memberof Season
         */
        league: MatchTeams;
        /**
         * @type {string}
         * @memberof Season
         */
        start_date: string;
        /**
         * @type {string}
         * @memberof Season
         */
        end_date: string;
        /**
         * @type {Array<MatchTeams>}
         * @memberof Season
         */
        teams: Array<MatchTeams>;
}


/**
 * 
 * @interface ISeasonError
 */
export interface ISeasonError {
    /**
     * 
     * @type {Array<string>}
     * @memberof SeasonError
     */
    name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SeasonError
     */
    league?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SeasonError
     */
    start_date?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SeasonError
     */
    end_date?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SeasonError
     */
    teams?: Array<string>;
}

/**
 * 
 * @class SeasonError
 */
export class SeasonError implements ISeasonError{
        /**
         * @type {Array<string>}
         * @memberof SeasonError
         */
        name: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof SeasonError
         */
        league: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof SeasonError
         */
        start_date: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof SeasonError
         */
        end_date: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof SeasonError
         */
        teams: Array<string>;
}


/**
 * 
 * @interface ISeasonList
 */
export interface ISeasonList {
    /**
     * 
     * @type {number}
     * @memberof SeasonList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof SeasonList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeasonList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Season>}
     * @memberof SeasonList
     */
    results?: Array<Season>;
}

/**
 * 
 * @class SeasonList
 */
export class SeasonList implements ISeasonList{
        /**
         * @type {number}
         * @memberof SeasonList
         */
        count: number;
        /**
         * @type {string}
         * @memberof SeasonList
         */
        next: string | null;
        /**
         * @type {string}
         * @memberof SeasonList
         */
        previous: string | null;
        /**
         * @type {Array<Season>}
         * @memberof SeasonList
         */
        results: Array<Season>;
}


/**
 * 
 * @interface ISession
 */
export interface ISession {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    csrf_token?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    expiry_date?: string;
}

/**
 * 
 * @class Session
 */
export class Session implements ISession{
        /**
         * @type {string}
         * @memberof Session
         */
        username: string;
        /**
         * @type {string}
         * @memberof Session
         */
        password: string;
        /**
         * @type {string}
         * @memberof Session
         */
        csrf_token: string;
        /**
         * @type {string}
         * @memberof Session
         */
        expiry_date: string;
}


/**
 * 
 * @interface ITeam
 */
export interface ITeam {
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    name: string;
    /**
     * 
     * @type {MatchTeams}
     * @memberof Team
     */
    league: MatchTeams;
    /**
     * 
     * @type {MatchTeams}
     * @memberof Team
     */
    season: MatchTeams;
    /**
     * 
     * @type {MatchTeams}
     * @memberof Team
     */
    captain: MatchTeams;
    /**
     * 
     * @type {Array<MatchTeams>}
     * @memberof Team
     */
    players?: Array<MatchTeams>;
}

/**
 * 
 * @class Team
 */
export class Team implements ITeam{
        /**
         * @type {number}
         * @memberof Team
         */
        id: number;
        /**
         * @type {string}
         * @memberof Team
         */
        url: string;
        /**
         * @type {string}
         * @memberof Team
         */
        name: string;
        /**
         * @type {MatchTeams}
         * @memberof Team
         */
        league: MatchTeams;
        /**
         * @type {MatchTeams}
         * @memberof Team
         */
        season: MatchTeams;
        /**
         * @type {MatchTeams}
         * @memberof Team
         */
        captain: MatchTeams;
        /**
         * @type {Array<MatchTeams>}
         * @memberof Team
         */
        players: Array<MatchTeams>;
}


/**
 * 
 * @interface ITeamError
 */
export interface ITeamError {
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamError
     */
    name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamError
     */
    league?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamError
     */
    season?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamError
     */
    captain?: Array<string>;
}

/**
 * 
 * @class TeamError
 */
export class TeamError implements ITeamError{
        /**
         * @type {Array<string>}
         * @memberof TeamError
         */
        name: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof TeamError
         */
        league: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof TeamError
         */
        season: Array<string>;
        /**
         * @type {Array<string>}
         * @memberof TeamError
         */
        captain: Array<string>;
}


/**
 * 
 * @interface ITeamList
 */
export interface ITeamList {
    /**
     * 
     * @type {number}
     * @memberof TeamList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TeamList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Team>}
     * @memberof TeamList
     */
    results?: Array<Team>;
}

/**
 * 
 * @class TeamList
 */
export class TeamList implements ITeamList{
        /**
         * @type {number}
         * @memberof TeamList
         */
        count: number;
        /**
         * @type {string}
         * @memberof TeamList
         */
        next: string | null;
        /**
         * @type {string}
         * @memberof TeamList
         */
        previous: string | null;
        /**
         * @type {Array<Team>}
         * @memberof TeamList
         */
        results: Array<Team>;
}


/**
 * 
 * @interface IUser
 */
export interface IUser {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    date_joined?: string;
    /**
     * Designates whether the user can log into this admin site.
     * @type {boolean}
     * @memberof User
     */
    is_staff?: boolean;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof User
     */
    is_superuser?: boolean;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof User
     */
    is_active?: boolean;
}

/**
 * 
 * @class User
 */
export class User implements IUser{
        /**
         * @type {number}
         * @memberof User
         */
        id: number;
        /**
         * @type {string}
         * @memberof User
         */
        email: string;
        /**
         * @type {string}
         * @memberof User
         */
        username: string;
        /**
         * @type {string}
         * @memberof User
         */
        first_name: string;
        /**
         * @type {string}
         * @memberof User
         */
        last_name: string;
        /**
         * @type {string}
         * @memberof User
         */
        date_joined: string;
        /**
         * @type {boolean}
         * @memberof User
         */
        is_staff: boolean;
        /**
         * @type {boolean}
         * @memberof User
         */
        is_superuser: boolean;
        /**
         * @type {boolean}
         * @memberof User
         */
        is_active: boolean;
}


/**
 * 
 * @interface IUserList
 */
export interface IUserList {
    /**
     * 
     * @type {number}
     * @memberof UserList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserList
     */
    results?: Array<User>;
}

/**
 * 
 * @class UserList
 */
export class UserList implements IUserList{
        /**
         * @type {number}
         * @memberof UserList
         */
        count: number;
        /**
         * @type {string}
         * @memberof UserList
         */
        next: string | null;
        /**
         * @type {string}
         * @memberof UserList
         */
        previous: string | null;
        /**
         * @type {Array<User>}
         * @memberof UserList
         */
        results: Array<User>;
}



/**
 * RestApi - axios parameter creator
 * @export
 */
export const RestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeague: async (league?: League, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/leagues/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(league, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Match} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMatch: async (match?: Match, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/matches/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(match, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer: async (player?: Player, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/players/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(player, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeason: async (season?: Season, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/seasons/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(season, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (team?: Team, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/teams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyLeague: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyLeague', 'id', id)
            const localVarPath = `/rest/leagues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMatch: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyMatch', 'id', id)
            const localVarPath = `/rest/matches/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPlayer: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyPlayer', 'id', id)
            const localVarPath = `/rest/players/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySeason: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySeason', 'id', id)
            const localVarPath = `/rest/seasons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyTeam: async (id: string, id2?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyTeam', 'id', id)
            const localVarPath = `/rest/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id2 !== undefined) {
                localVarQueryParameter['id'] = id2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLeagues: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/leagues/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMatchs: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/matches/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayers: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/players/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSeasons: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/seasons/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams: async (page?: number, id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/teams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateLeague: async (id: string, league?: League, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateLeague', 'id', id)
            const localVarPath = `/rest/leagues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(league, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {Match} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMatch: async (id: string, match?: Match, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateMatch', 'id', id)
            const localVarPath = `/rest/matches/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(match, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdatePlayer: async (id: string, player?: Player, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdatePlayer', 'id', id)
            const localVarPath = `/rest/players/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(player, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSeason: async (id: string, season?: Season, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSeason', 'id', id)
            const localVarPath = `/rest/seasons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(season, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateTeam: async (id: string, id2?: string, team?: Team, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateTeam', 'id', id)
            const localVarPath = `/rest/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id2 !== undefined) {
                localVarQueryParameter['id'] = id2;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveLeague: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveLeague', 'id', id)
            const localVarPath = `/rest/leagues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMatch: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveMatch', 'id', id)
            const localVarPath = `/rest/matches/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePlayer: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrievePlayer', 'id', id)
            const localVarPath = `/rest/players/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSeason: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSeason', 'id', id)
            const localVarPath = `/rest/seasons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTeam: async (id: string, id2?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveTeam', 'id', id)
            const localVarPath = `/rest/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id2 !== undefined) {
                localVarQueryParameter['id'] = id2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUser', 'id', id)
            const localVarPath = `/rest/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeague: async (id: string, league?: League, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLeague', 'id', id)
            const localVarPath = `/rest/leagues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(league, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {Match} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMatch: async (id: string, match?: Match, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMatch', 'id', id)
            const localVarPath = `/rest/matches/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(match, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer: async (id: string, player?: Player, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlayer', 'id', id)
            const localVarPath = `/rest/players/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(player, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeason: async (id: string, season?: Season, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSeason', 'id', id)
            const localVarPath = `/rest/seasons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(season, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam: async (id: string, id2?: string, team?: Team, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTeam', 'id', id)
            const localVarPath = `/rest/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id2 !== undefined) {
                localVarQueryParameter['id'] = id2;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestApi - functional programming interface
 * @export
 */
export const RestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeague(league?: League, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<League>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeague(league, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Match} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMatch(match?: Match, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Match>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMatch(match, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayer(player?: Player, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Player>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlayer(player, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSeason(season?: Season, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Season>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSeason(season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(team?: Team, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyLeague(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyLeague(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyMatch(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyMatch(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyPlayer(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyPlayer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySeason(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySeason(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyTeam(id: string, id2?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyTeam(id, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLeagues(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeagueList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLeagues(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMatchs(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMatchs(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlayers(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlayers(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSeasons(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeasonList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSeasons(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeams(page?: number, id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeams(page, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateLeague(id: string, league?: League, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<League>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateLeague(id, league, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {Match} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateMatch(id: string, match?: Match, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Match>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateMatch(id, match, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdatePlayer(id: string, player?: Player, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Player>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdatePlayer(id, player, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSeason(id: string, season?: Season, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Season>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSeason(id, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateTeam(id: string, id2?: string, team?: Team, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateTeam(id, id2, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveLeague(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<League>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveLeague(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveMatch(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Match>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveMatch(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePlayer(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Player>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePlayer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSeason(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Season>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSeason(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveTeam(id: string, id2?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveTeam(id, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLeague(id: string, league?: League, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<League>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLeague(id, league, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {Match} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMatch(id: string, match?: Match, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Match>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMatch(id, match, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlayer(id: string, player?: Player, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Player>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlayer(id, player, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSeason(id: string, season?: Season, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Season>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSeason(id, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeam(id: string, id2?: string, team?: Team, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeam(id, id2, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RestApi - factory interface
 * @export
 */
export const RestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestApiFp(configuration)
    return {
        /**
         * 
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeague(league?: League, options?: any): AxiosPromise<League> {
            return localVarFp.createLeague(league, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Match} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMatch(match?: Match, options?: any): AxiosPromise<Match> {
            return localVarFp.createMatch(match, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer(player?: Player, options?: any): AxiosPromise<Player> {
            return localVarFp.createPlayer(player, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeason(season?: Season, options?: any): AxiosPromise<Season> {
            return localVarFp.createSeason(season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(team?: Team, options?: any): AxiosPromise<Team> {
            return localVarFp.createTeam(team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyLeague(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyLeague(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMatch(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyMatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPlayer(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyPlayer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySeason(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroySeason(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyTeam(id: string, id2?: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyTeam(id, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLeagues(page?: number, options?: any): AxiosPromise<LeagueList> {
            return localVarFp.listLeagues(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMatchs(page?: number, options?: any): AxiosPromise<MatchList> {
            return localVarFp.listMatchs(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayers(page?: number, options?: any): AxiosPromise<PlayerList> {
            return localVarFp.listPlayers(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSeasons(page?: number, options?: any): AxiosPromise<SeasonList> {
            return localVarFp.listSeasons(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {string} [id] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(page?: number, id?: string, options?: any): AxiosPromise<TeamList> {
            return localVarFp.listTeams(page, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, options?: any): AxiosPromise<UserList> {
            return localVarFp.listUsers(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateLeague(id: string, league?: League, options?: any): AxiosPromise<League> {
            return localVarFp.partialUpdateLeague(id, league, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {Match} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMatch(id: string, match?: Match, options?: any): AxiosPromise<Match> {
            return localVarFp.partialUpdateMatch(id, match, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdatePlayer(id: string, player?: Player, options?: any): AxiosPromise<Player> {
            return localVarFp.partialUpdatePlayer(id, player, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSeason(id: string, season?: Season, options?: any): AxiosPromise<Season> {
            return localVarFp.partialUpdateSeason(id, season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateTeam(id: string, id2?: string, team?: Team, options?: any): AxiosPromise<Team> {
            return localVarFp.partialUpdateTeam(id, id2, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveLeague(id: string, options?: any): AxiosPromise<League> {
            return localVarFp.retrieveLeague(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMatch(id: string, options?: any): AxiosPromise<Match> {
            return localVarFp.retrieveMatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePlayer(id: string, options?: any): AxiosPromise<Player> {
            return localVarFp.retrievePlayer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSeason(id: string, options?: any): AxiosPromise<Season> {
            return localVarFp.retrieveSeason(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTeam(id: string, id2?: string, options?: any): AxiosPromise<Team> {
            return localVarFp.retrieveTeam(id, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.retrieveUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeague(id: string, league?: League, options?: any): AxiosPromise<League> {
            return localVarFp.updateLeague(id, league, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this match.
         * @param {Match} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMatch(id: string, match?: Match, options?: any): AxiosPromise<Match> {
            return localVarFp.updateMatch(id, match, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(id: string, player?: Player, options?: any): AxiosPromise<Player> {
            return localVarFp.updatePlayer(id, player, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeason(id: string, season?: Season, options?: any): AxiosPromise<Season> {
            return localVarFp.updateSeason(id, season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {string} [id2] id
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(id: string, id2?: string, team?: Team, options?: any): AxiosPromise<Team> {
            return localVarFp.updateTeam(id, id2, team, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestApi - interface
 * @export
 * @interface RestApi
 */
export interface RestApiInterface {
    /**
     * 
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    createLeague(league?: League, options?: any): AxiosPromise<League>;

    /**
     * 
     * @param {Match} [match] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    createMatch(match?: Match, options?: any): AxiosPromise<Match>;

    /**
     * 
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    createPlayer(player?: Player, options?: any): AxiosPromise<Player>;

    /**
     * 
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    createSeason(season?: Season, options?: any): AxiosPromise<Season>;

    /**
     * 
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    createTeam(team?: Team, options?: any): AxiosPromise<Team>;

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    destroyLeague(id: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} id A unique integer value identifying this match.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    destroyMatch(id: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    destroyPlayer(id: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    destroySeason(id: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {string} [id2] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    destroyTeam(id: string, id2?: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listLeagues(page?: number, options?: any): AxiosPromise<LeagueList>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listMatchs(page?: number, options?: any): AxiosPromise<MatchList>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listPlayers(page?: number, options?: any): AxiosPromise<PlayerList>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listSeasons(page?: number, options?: any): AxiosPromise<SeasonList>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [id] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listTeams(page?: number, id?: string, options?: any): AxiosPromise<TeamList>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listUsers(page?: number, options?: any): AxiosPromise<UserList>;

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    partialUpdateLeague(id: string, league?: League, options?: any): AxiosPromise<League>;

    /**
     * 
     * @param {string} id A unique integer value identifying this match.
     * @param {Match} [match] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    partialUpdateMatch(id: string, match?: Match, options?: any): AxiosPromise<Match>;

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    partialUpdatePlayer(id: string, player?: Player, options?: any): AxiosPromise<Player>;

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    partialUpdateSeason(id: string, season?: Season, options?: any): AxiosPromise<Season>;

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {string} [id2] id
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    partialUpdateTeam(id: string, id2?: string, team?: Team, options?: any): AxiosPromise<Team>;

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrieveLeague(id: string, options?: any): AxiosPromise<League>;

    /**
     * 
     * @param {string} id A unique integer value identifying this match.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrieveMatch(id: string, options?: any): AxiosPromise<Match>;

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrievePlayer(id: string, options?: any): AxiosPromise<Player>;

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrieveSeason(id: string, options?: any): AxiosPromise<Season>;

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {string} [id2] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrieveTeam(id: string, id2?: string, options?: any): AxiosPromise<Team>;

    /**
     * 
     * @param {string} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrieveUser(id: string, options?: any): AxiosPromise<User>;

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    updateLeague(id: string, league?: League, options?: any): AxiosPromise<League>;

    /**
     * 
     * @param {string} id A unique integer value identifying this match.
     * @param {Match} [match] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    updateMatch(id: string, match?: Match, options?: any): AxiosPromise<Match>;

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    updatePlayer(id: string, player?: Player, options?: any): AxiosPromise<Player>;

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    updateSeason(id: string, season?: Season, options?: any): AxiosPromise<Season>;

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {string} [id2] id
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    updateTeam(id: string, id2?: string, team?: Team, options?: any): AxiosPromise<Team>;

}

/**
 * RestApi - object-oriented interface
 * @export
 * @class RestApi
 * @extends {BaseAPI}
 */
export class RestApi extends BaseAPI implements RestApiInterface {
    /**
     * 
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public createLeague(league?: League, options?: any) {
        return RestApiFp(this.configuration).createLeague(league, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Match} [match] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public createMatch(match?: Match, options?: any) {
        return RestApiFp(this.configuration).createMatch(match, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public createPlayer(player?: Player, options?: any) {
        return RestApiFp(this.configuration).createPlayer(player, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public createSeason(season?: Season, options?: any) {
        return RestApiFp(this.configuration).createSeason(season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public createTeam(team?: Team, options?: any) {
        return RestApiFp(this.configuration).createTeam(team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public destroyLeague(id: string, options?: any) {
        return RestApiFp(this.configuration).destroyLeague(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this match.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public destroyMatch(id: string, options?: any) {
        return RestApiFp(this.configuration).destroyMatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public destroyPlayer(id: string, options?: any) {
        return RestApiFp(this.configuration).destroyPlayer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public destroySeason(id: string, options?: any) {
        return RestApiFp(this.configuration).destroySeason(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {string} [id2] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public destroyTeam(id: string, id2?: string, options?: any) {
        return RestApiFp(this.configuration).destroyTeam(id, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listLeagues(page?: number, options?: any) {
        return RestApiFp(this.configuration).listLeagues(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listMatchs(page?: number, options?: any) {
        return RestApiFp(this.configuration).listMatchs(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listPlayers(page?: number, options?: any) {
        return RestApiFp(this.configuration).listPlayers(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listSeasons(page?: number, options?: any) {
        return RestApiFp(this.configuration).listSeasons(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {string} [id] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listTeams(page?: number, id?: string, options?: any) {
        return RestApiFp(this.configuration).listTeams(page, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listUsers(page?: number, options?: any) {
        return RestApiFp(this.configuration).listUsers(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public partialUpdateLeague(id: string, league?: League, options?: any) {
        return RestApiFp(this.configuration).partialUpdateLeague(id, league, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this match.
     * @param {Match} [match] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public partialUpdateMatch(id: string, match?: Match, options?: any) {
        return RestApiFp(this.configuration).partialUpdateMatch(id, match, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public partialUpdatePlayer(id: string, player?: Player, options?: any) {
        return RestApiFp(this.configuration).partialUpdatePlayer(id, player, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public partialUpdateSeason(id: string, season?: Season, options?: any) {
        return RestApiFp(this.configuration).partialUpdateSeason(id, season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {string} [id2] id
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public partialUpdateTeam(id: string, id2?: string, team?: Team, options?: any) {
        return RestApiFp(this.configuration).partialUpdateTeam(id, id2, team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrieveLeague(id: string, options?: any) {
        return RestApiFp(this.configuration).retrieveLeague(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this match.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrieveMatch(id: string, options?: any) {
        return RestApiFp(this.configuration).retrieveMatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrievePlayer(id: string, options?: any) {
        return RestApiFp(this.configuration).retrievePlayer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrieveSeason(id: string, options?: any) {
        return RestApiFp(this.configuration).retrieveSeason(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {string} [id2] id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrieveTeam(id: string, id2?: string, options?: any) {
        return RestApiFp(this.configuration).retrieveTeam(id, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrieveUser(id: string, options?: any) {
        return RestApiFp(this.configuration).retrieveUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public updateLeague(id: string, league?: League, options?: any) {
        return RestApiFp(this.configuration).updateLeague(id, league, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this match.
     * @param {Match} [match] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public updateMatch(id: string, match?: Match, options?: any) {
        return RestApiFp(this.configuration).updateMatch(id, match, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public updatePlayer(id: string, player?: Player, options?: any) {
        return RestApiFp(this.configuration).updatePlayer(id, player, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public updateSeason(id: string, season?: Season, options?: any) {
        return RestApiFp(this.configuration).updateSeason(id, season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {string} [id2] id
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public updateTeam(id: string, id2?: string, team?: Team, options?: any) {
        return RestApiFp(this.configuration).updateTeam(id, id2, team, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Profile} [profile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (profile?: Profile, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchedules: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/schedule/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Profile} [profile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateProfile: async (profile?: Profile, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProfile: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSession: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/session/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Profile} [profile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (profile?: Profile, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Session} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSession: async (session?: Session, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/session/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(session, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Profile} [profile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(profile?: Profile, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfile(profile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchedules(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchedules(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Profile} [profile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateProfile(profile?: Profile, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateProfile(profile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProfile(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProfile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSession(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Profile} [profile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(profile?: Profile, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfile(profile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Session} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSession(session?: Session, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSession(session, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {Profile} [profile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(profile?: Profile, options?: any): AxiosPromise<Profile> {
            return localVarFp.createProfile(profile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchedules(page?: number, options?: any): AxiosPromise<ScheduleList> {
            return localVarFp.listSchedules(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Profile} [profile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateProfile(profile?: Profile, options?: any): AxiosPromise<Profile> {
            return localVarFp.partialUpdateProfile(profile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProfile(options?: any): AxiosPromise<Profile> {
            return localVarFp.retrieveProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSession(options?: any): AxiosPromise<Session> {
            return localVarFp.retrieveSession(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Profile} [profile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(profile?: Profile, options?: any): AxiosPromise<Profile> {
            return localVarFp.updateProfile(profile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Session} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSession(session?: Session, options?: any): AxiosPromise<Session> {
            return localVarFp.updateSession(session, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * 
     * @param {Profile} [profile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    createProfile(profile?: Profile, options?: any): AxiosPromise<Profile>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listSchedules(page?: number, options?: any): AxiosPromise<ScheduleList>;

    /**
     * 
     * @param {Profile} [profile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    partialUpdateProfile(profile?: Profile, options?: any): AxiosPromise<Profile>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    retrieveProfile(options?: any): AxiosPromise<Profile>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    retrieveSession(options?: any): AxiosPromise<Session>;

    /**
     * 
     * @param {Profile} [profile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateProfile(profile?: Profile, options?: any): AxiosPromise<Profile>;

    /**
     * 
     * @param {Session} [session] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateSession(session?: Session, options?: any): AxiosPromise<Session>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * 
     * @param {Profile} [profile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createProfile(profile?: Profile, options?: any) {
        return UserApiFp(this.configuration).createProfile(profile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listSchedules(page?: number, options?: any) {
        return UserApiFp(this.configuration).listSchedules(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Profile} [profile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public partialUpdateProfile(profile?: Profile, options?: any) {
        return UserApiFp(this.configuration).partialUpdateProfile(profile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public retrieveProfile(options?: any) {
        return UserApiFp(this.configuration).retrieveProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public retrieveSession(options?: any) {
        return UserApiFp(this.configuration).retrieveSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Profile} [profile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateProfile(profile?: Profile, options?: any) {
        return UserApiFp(this.configuration).updateProfile(profile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Session} [session] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateSession(session?: Session, options?: any) {
        return UserApiFp(this.configuration).updateSession(session, options).then((request) => request(this.axios, this.basePath));
    }
}


