/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof InlineResponse200
     */
    results?: Array<User>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Player>}
     * @memberof InlineResponse2001
     */
    results?: Array<Player>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Team>}
     * @memberof InlineResponse2002
     */
    results?: Array<Team>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Season>}
     * @memberof InlineResponse2003
     */
    results?: Array<Season>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<League>}
     * @memberof InlineResponse2004
     */
    results?: Array<League>;
}
/**
 * 
 * @export
 * @interface League
 */
export interface League {
    /**
     * 
     * @type {number}
     * @memberof League
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    name: string;
}
/**
 * 
 * @export
 * @interface LeagueError
 */
export interface LeagueError {
    /**
     * 
     * @type {Array<string>}
     * @memberof LeagueError
     */
    name?: Array<string>;
}
/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    last_name: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    first_name: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    display_name?: string;
    /**
     * 
     * @type {Array<PlayerTeams>}
     * @memberof Player
     */
    teams?: Array<PlayerTeams>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Player
     */
    team_ids?: Array<number>;
}
/**
 * 
 * @export
 * @interface PlayerError
 */
export interface PlayerError {
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    email?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    password?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    last_name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    first_name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    display_name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerError
     */
    team_ids?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlayerTeams
 */
export interface PlayerTeams {
    /**
     * 
     * @type {number}
     * @memberof PlayerTeams
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerTeams
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerTeams
     */
    name: string;
}
/**
 * 
 * @export
 * @interface Season
 */
export interface Season {
    /**
     * 
     * @type {number}
     * @memberof Season
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    name: string;
    /**
     * 
     * @type {PlayerTeams}
     * @memberof Season
     */
    league: PlayerTeams;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    start_date: string;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    end_date: string;
    /**
     * 
     * @type {Array<PlayerTeams>}
     * @memberof Season
     */
    teams: Array<PlayerTeams>;
}
/**
 * 
 * @export
 * @interface SeasonError
 */
export interface SeasonError {
    /**
     * 
     * @type {Array<string>}
     * @memberof SeasonError
     */
    name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SeasonError
     */
    league?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SeasonError
     */
    start_date?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SeasonError
     */
    end_date?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SeasonError
     */
    teams?: Array<string>;
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    name: string;
    /**
     * 
     * @type {PlayerTeams}
     * @memberof Team
     */
    league: PlayerTeams;
    /**
     * 
     * @type {PlayerTeams}
     * @memberof Team
     */
    season: PlayerTeams;
    /**
     * 
     * @type {TeamCaptain}
     * @memberof Team
     */
    captain: TeamCaptain;
    /**
     * 
     * @type {Array<TeamCaptain>}
     * @memberof Team
     */
    players?: Array<TeamCaptain>;
}
/**
 * 
 * @export
 * @interface TeamCaptain
 */
export interface TeamCaptain {
    /**
     * 
     * @type {number}
     * @memberof TeamCaptain
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamCaptain
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamCaptain
     */
    display_name?: string;
}
/**
 * 
 * @export
 * @interface TeamError
 */
export interface TeamError {
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamError
     */
    name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamError
     */
    league?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamError
     */
    season?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamError
     */
    captain?: Array<string>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    date_joined?: string;
    /**
     * Designates whether the user can log into this admin site.
     * @type {boolean}
     * @memberof User
     */
    is_staff?: boolean;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof User
     */
    is_superuser?: boolean;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof User
     */
    is_active?: boolean;
}

/**
 * RestApi - axios parameter creator
 * @export
 */
export const RestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeague: async (league?: League, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/leagues/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(league, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer: async (player?: Player, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/players/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(player, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeason: async (season?: Season, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/seasons/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(season, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (team?: Team, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/teams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyLeague: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyLeague', 'id', id)
            const localVarPath = `/rest/leagues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPlayer: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyPlayer', 'id', id)
            const localVarPath = `/rest/players/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySeason: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySeason', 'id', id)
            const localVarPath = `/rest/seasons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyTeam: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyTeam', 'id', id)
            const localVarPath = `/rest/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLeagues: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/leagues/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayers: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/players/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSeasons: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/seasons/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/teams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateLeague: async (id: string, league?: League, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateLeague', 'id', id)
            const localVarPath = `/rest/leagues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(league, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdatePlayer: async (id: string, player?: Player, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdatePlayer', 'id', id)
            const localVarPath = `/rest/players/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(player, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSeason: async (id: string, season?: Season, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSeason', 'id', id)
            const localVarPath = `/rest/seasons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(season, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateTeam: async (id: string, team?: Team, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateTeam', 'id', id)
            const localVarPath = `/rest/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveLeague: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveLeague', 'id', id)
            const localVarPath = `/rest/leagues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePlayer: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrievePlayer', 'id', id)
            const localVarPath = `/rest/players/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSeason: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSeason', 'id', id)
            const localVarPath = `/rest/seasons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTeam: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveTeam', 'id', id)
            const localVarPath = `/rest/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUser', 'id', id)
            const localVarPath = `/rest/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeague: async (id: string, league?: League, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLeague', 'id', id)
            const localVarPath = `/rest/leagues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(league, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer: async (id: string, player?: Player, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlayer', 'id', id)
            const localVarPath = `/rest/players/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(player, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeason: async (id: string, season?: Season, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSeason', 'id', id)
            const localVarPath = `/rest/seasons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(season, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam: async (id: string, team?: Team, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTeam', 'id', id)
            const localVarPath = `/rest/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestApi - functional programming interface
 * @export
 */
export const RestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeague(league?: League, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<League>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeague(league, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayer(player?: Player, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Player>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlayer(player, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSeason(season?: Season, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Season>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSeason(season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(team?: Team, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyLeague(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyLeague(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyPlayer(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyPlayer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySeason(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySeason(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyTeam(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyTeam(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLeagues(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLeagues(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlayers(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlayers(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSeasons(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSeasons(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeams(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeams(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateLeague(id: string, league?: League, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<League>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateLeague(id, league, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdatePlayer(id: string, player?: Player, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Player>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdatePlayer(id, player, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSeason(id: string, season?: Season, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Season>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSeason(id, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateTeam(id: string, team?: Team, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateTeam(id, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveLeague(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<League>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveLeague(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePlayer(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Player>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePlayer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSeason(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Season>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSeason(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveTeam(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveTeam(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLeague(id: string, league?: League, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<League>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLeague(id, league, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlayer(id: string, player?: Player, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Player>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlayer(id, player, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSeason(id: string, season?: Season, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Season>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSeason(id, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeam(id: string, team?: Team, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeam(id, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RestApi - factory interface
 * @export
 */
export const RestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestApiFp(configuration)
    return {
        /**
         * 
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeague(league?: League, options?: any): AxiosPromise<League> {
            return localVarFp.createLeague(league, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer(player?: Player, options?: any): AxiosPromise<Player> {
            return localVarFp.createPlayer(player, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeason(season?: Season, options?: any): AxiosPromise<Season> {
            return localVarFp.createSeason(season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(team?: Team, options?: any): AxiosPromise<Team> {
            return localVarFp.createTeam(team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyLeague(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyLeague(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPlayer(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyPlayer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySeason(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroySeason(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyTeam(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyTeam(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLeagues(page?: number, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.listLeagues(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayers(page?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.listPlayers(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSeasons(page?: number, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.listSeasons(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(page?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.listTeams(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.listUsers(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateLeague(id: string, league?: League, options?: any): AxiosPromise<League> {
            return localVarFp.partialUpdateLeague(id, league, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdatePlayer(id: string, player?: Player, options?: any): AxiosPromise<Player> {
            return localVarFp.partialUpdatePlayer(id, player, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSeason(id: string, season?: Season, options?: any): AxiosPromise<Season> {
            return localVarFp.partialUpdateSeason(id, season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateTeam(id: string, team?: Team, options?: any): AxiosPromise<Team> {
            return localVarFp.partialUpdateTeam(id, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveLeague(id: string, options?: any): AxiosPromise<League> {
            return localVarFp.retrieveLeague(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePlayer(id: string, options?: any): AxiosPromise<Player> {
            return localVarFp.retrievePlayer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSeason(id: string, options?: any): AxiosPromise<Season> {
            return localVarFp.retrieveSeason(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTeam(id: string, options?: any): AxiosPromise<Team> {
            return localVarFp.retrieveTeam(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.retrieveUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this league.
         * @param {League} [league] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeague(id: string, league?: League, options?: any): AxiosPromise<League> {
            return localVarFp.updateLeague(id, league, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this player.
         * @param {Player} [player] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(id: string, player?: Player, options?: any): AxiosPromise<Player> {
            return localVarFp.updatePlayer(id, player, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this season.
         * @param {Season} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeason(id: string, season?: Season, options?: any): AxiosPromise<Season> {
            return localVarFp.updateSeason(id, season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this team.
         * @param {Team} [team] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(id: string, team?: Team, options?: any): AxiosPromise<Team> {
            return localVarFp.updateTeam(id, team, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestApi - interface
 * @export
 * @interface RestApi
 */
export interface RestApiInterface {
    /**
     * 
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    createLeague(league?: League, options?: any): AxiosPromise<League>;

    /**
     * 
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    createPlayer(player?: Player, options?: any): AxiosPromise<Player>;

    /**
     * 
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    createSeason(season?: Season, options?: any): AxiosPromise<Season>;

    /**
     * 
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    createTeam(team?: Team, options?: any): AxiosPromise<Team>;

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    destroyLeague(id: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    destroyPlayer(id: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    destroySeason(id: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    destroyTeam(id: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listLeagues(page?: number, options?: any): AxiosPromise<InlineResponse2004>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listPlayers(page?: number, options?: any): AxiosPromise<InlineResponse2001>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listSeasons(page?: number, options?: any): AxiosPromise<InlineResponse2003>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listTeams(page?: number, options?: any): AxiosPromise<InlineResponse2002>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    listUsers(page?: number, options?: any): AxiosPromise<InlineResponse200>;

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    partialUpdateLeague(id: string, league?: League, options?: any): AxiosPromise<League>;

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    partialUpdatePlayer(id: string, player?: Player, options?: any): AxiosPromise<Player>;

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    partialUpdateSeason(id: string, season?: Season, options?: any): AxiosPromise<Season>;

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    partialUpdateTeam(id: string, team?: Team, options?: any): AxiosPromise<Team>;

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrieveLeague(id: string, options?: any): AxiosPromise<League>;

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrievePlayer(id: string, options?: any): AxiosPromise<Player>;

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrieveSeason(id: string, options?: any): AxiosPromise<Season>;

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrieveTeam(id: string, options?: any): AxiosPromise<Team>;

    /**
     * 
     * @param {string} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    retrieveUser(id: string, options?: any): AxiosPromise<User>;

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    updateLeague(id: string, league?: League, options?: any): AxiosPromise<League>;

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    updatePlayer(id: string, player?: Player, options?: any): AxiosPromise<Player>;

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    updateSeason(id: string, season?: Season, options?: any): AxiosPromise<Season>;

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApiInterface
     */
    updateTeam(id: string, team?: Team, options?: any): AxiosPromise<Team>;

}

/**
 * RestApi - object-oriented interface
 * @export
 * @class RestApi
 * @extends {BaseAPI}
 */
export class RestApi extends BaseAPI implements RestApiInterface {
    /**
     * 
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public createLeague(league?: League, options?: any) {
        return RestApiFp(this.configuration).createLeague(league, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public createPlayer(player?: Player, options?: any) {
        return RestApiFp(this.configuration).createPlayer(player, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public createSeason(season?: Season, options?: any) {
        return RestApiFp(this.configuration).createSeason(season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public createTeam(team?: Team, options?: any) {
        return RestApiFp(this.configuration).createTeam(team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public destroyLeague(id: string, options?: any) {
        return RestApiFp(this.configuration).destroyLeague(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public destroyPlayer(id: string, options?: any) {
        return RestApiFp(this.configuration).destroyPlayer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public destroySeason(id: string, options?: any) {
        return RestApiFp(this.configuration).destroySeason(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public destroyTeam(id: string, options?: any) {
        return RestApiFp(this.configuration).destroyTeam(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listLeagues(page?: number, options?: any) {
        return RestApiFp(this.configuration).listLeagues(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listPlayers(page?: number, options?: any) {
        return RestApiFp(this.configuration).listPlayers(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listSeasons(page?: number, options?: any) {
        return RestApiFp(this.configuration).listSeasons(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listTeams(page?: number, options?: any) {
        return RestApiFp(this.configuration).listTeams(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public listUsers(page?: number, options?: any) {
        return RestApiFp(this.configuration).listUsers(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public partialUpdateLeague(id: string, league?: League, options?: any) {
        return RestApiFp(this.configuration).partialUpdateLeague(id, league, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public partialUpdatePlayer(id: string, player?: Player, options?: any) {
        return RestApiFp(this.configuration).partialUpdatePlayer(id, player, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public partialUpdateSeason(id: string, season?: Season, options?: any) {
        return RestApiFp(this.configuration).partialUpdateSeason(id, season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public partialUpdateTeam(id: string, team?: Team, options?: any) {
        return RestApiFp(this.configuration).partialUpdateTeam(id, team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrieveLeague(id: string, options?: any) {
        return RestApiFp(this.configuration).retrieveLeague(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrievePlayer(id: string, options?: any) {
        return RestApiFp(this.configuration).retrievePlayer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrieveSeason(id: string, options?: any) {
        return RestApiFp(this.configuration).retrieveSeason(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrieveTeam(id: string, options?: any) {
        return RestApiFp(this.configuration).retrieveTeam(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public retrieveUser(id: string, options?: any) {
        return RestApiFp(this.configuration).retrieveUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this league.
     * @param {League} [league] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public updateLeague(id: string, league?: League, options?: any) {
        return RestApiFp(this.configuration).updateLeague(id, league, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this player.
     * @param {Player} [player] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public updatePlayer(id: string, player?: Player, options?: any) {
        return RestApiFp(this.configuration).updatePlayer(id, player, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this season.
     * @param {Season} [season] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public updateSeason(id: string, season?: Season, options?: any) {
        return RestApiFp(this.configuration).updateSeason(id, season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this team.
     * @param {Team} [team] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public updateTeam(id: string, team?: Team, options?: any) {
        return RestApiFp(this.configuration).updateTeam(id, team, options).then((request) => request(this.axios, this.basePath));
    }
}


